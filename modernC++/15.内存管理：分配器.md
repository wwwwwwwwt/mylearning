<!--
 * @Author: zzzzztw
 * @Date: 2023-09-16 10:54:36
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-09-17 19:57:29
 * @FilePath: /myLearning/modernC++/15.内存管理：分配器.md
-->
# C++ 内存管理与分配器

## new 与 delete

### 最常用的分配与释放内存形式

```cpp
void* operator new(size_t size)
{
    void *ptr = malloc(size);
    if(ptr == nullptr){
        throw bad_alloc();
    }
    return ptr;
}
void operator delete(void* ptr)noexcept
{
    free(ptr);
}
```
* 注意 new 是允许抛出异常的，它不会返回一个空指针，而是直接抛出异常。delete不允许抛出异常，原因如析构函数通常不抛出异常的原因一致，异常展开析构对象时，析构函数也异常的话两个异常碰到一起会崩溃。

```cpp
void* operator new[](size_t size){
    return operator new(size);
}
void operator delete[](void* ptr)noexcept
{
    operator delete(ptr);
}

```

### 无异常编程情况下的重载

```cpp
struct nothrow_t {
  explicit nothrow_t() = default;
};

extern const nothrow_t nothrow;

void* operator new(
  size_t size,
  const nothrow_t&) noexcept;
void* operator new[](
  size_t size,
  const nothrow_t&) noexcept;

```
* 重载new(std::nothrow)Obj会走这个函数，不抛出异常，返回一个空指针。

### 不分配内存，定位new

```cpp
inline void*
operator new(size_t,
             void* ptr) noexcept
{ return ptr; }

inline void
operator delete(void*,
                void*) noexcept
{}
```

## 分配器

1. c++最早沿用SGI分配器
   1. ```alloc```:线程安全的默认分配器，分配小于128字节的需要使用内存池，超过128字节的需要使用malloc_alloc
   2. ```pthread_alloc```：每个线程使用单独的内存池分配器
   3. ```single_client_alloc```:线程不安全的快速分配器
   4. ```malloc_alloc```:调用malloc和free分配和释放内存