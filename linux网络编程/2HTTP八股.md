<!--
 * @Author: zzzzztw
 * @Date: 2023-05-21 22:01:43
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-05-23 21:21:20
 * @FilePath: /myLearning/linux网络编程/2HTTP八股.md
-->
# HTTP

### 1. Http超文本传输协议->双向协议->允许A-B之间有中转->两点之间传输数据的约定和规范
### 2. 超文本包括文本图片文字视频等混合体，还有超链接
### 3. 五类状态码：
   1. 1xx 提示信息，post的中间状态，表示continue
   2. 2xx 成功
   3. 3xx 服务器数据变了，重定向错误
   4. 4xx 客户端发送的请求有错，服务端无法处理
   5. 5xx 报文正确，但服务器内部报错了
### 4. http常见字段：
   1. host：用于指定服务器的域名
   2. content-length：报文内容长度
      1. http协议使用回车 + 换行符\r\n确定header的边界， 使用content-length作为数据的边界，用于解决粘包
   3. connection: 连接类型， keep-alive 长连接，三次握手建立连接后保持连接到四次挥手结束
   4. content-type：服务器回应时，数据格式， 字符编码格式等， text/html， utf-8等
   5. Accept：请求时，高速服务器自己可以接受的格式
   6. content-encoding: 压缩格式
   7. accept-encoding：可以接收的压缩格式
### 5.GET与POST有什么区别：

#### get：
1. get请求可以被缓存
2. get请求保留在了浏览器的历史记录中
3. get请求可以收藏为数千
4. get请求有长度限制，url最大2048字节
5. get请求一般只用于请求数据

#### post：
1. post一般作为请求数据
2. post请求对长度没有要求
3. post不能当作书签
4. post请求不会被缓存

#### 重点不同，get请求只会产生一个tcp报文包， post会产生两个
* post请求：
  * 客户端发送请求syn，第一次请求握手
  * 服务端响应ack并且请求syn，第二次握手
  * 客户端回应ack并发送post请求头（第一个tcp包）
  * 服务端返回100continue响应
  * 客户端发送报文体（第二个tcp包）
  * 客户端返回数据和200响应
* get请求：
  * 客户端发送请求syn， 第一次握手
  * 服务端响应ack并发送syn请求，第二次握手
  * 客户端响应ack，并发送get请求头和数据， 第三次握手（第一个tcp包）
  * 服务器响应200 返回数据。

### 6.http缓存技术
两种技术
1. 强制缓存：只要资源没过期就一直使用缓存
2. 协商缓存：资源过期了就去服务器验证一下资源标识变了没，如果没变还是使用缓存

### 7.http/1.1 特点

1. 简单：基于报文格式header + body 头部信息采用key-value形式
2. 灵活易于扩展: 协议里的各种请求方法，url，状态码，头部字段都没有被固定化，利于变化
3. 工作在应用层，是最顶层，下层可以随意变化，例如https就是再http + TLS/SSL安全传输层
4. http1.1 http2.0采用tcp http3.0采用udp
5. 跨平台
#### 双刃剑的缺点，无状态，明文传输
1. 无状态：
   1. 好处：服务器不会记录http状态，减轻服务器的负担
   2. 坏处：服务器没有记忆能力，在关联性操作时会麻烦
   3. 解决方法：引入了cookie，第一次请求后，给客户端发送一个cookie，在这个cookie的有效期内，都可以直接不用密码
2. 明文传输：危险，能看到http内的所有信息
3. 不安全未使用加密，不验证双发信息，可能被窃听伪装篡改
4. 解决：https

### 8.http性能
1. 使用了keep-alive的长连接，在此之前每一次响应-请求都会断开连接，下次重新三次握手。采用keep-alive一次三次握手，直到最后断开连接，期间所有请求响应都直接发。
2. 管道网络传输，不常用。第一个请求出去了，不必等其回来，直接可以发送第二个请求。但服务器必须按照请求的顺序对其响应，如果服务器处理A响应太久，后续的响应都将被阻塞住。叫队头阻塞。注意：解决了请求的对头阻塞，没有解决响应的队头阻塞。不是默认开起的。

### 9.http 与 https
#### 区别：
   1. http明文传输，https在tcp层和http层之间加了SSL/TLS安全协议，使报文能加密传输
   2. http在三次握手后即可进行数据传输，https在三次握手后还需要进行SSL/TLS握手，才能进行数据传输
   3. http默认端口80， https默认端口443
   4. https需要向CA证书机构申请数字证书，来保证服务器身份可信

#### https SSL/TLS四次握手的过程
1. client发送请求：
   1. 生成第一个随机数
   2. 客户端支持的SSL/TLS协议版本
   3. 支持的加密算法RSA等
2. server收到请求并响应：
   1. 确认客户端支持的SSL版本
   2. 生成第二个随机数
   3. 确认密码套件
   4. 服务器自己的CA证书
3. client响应请求：
   1. 客户端收到服务器发来的请求。
   2. 首先使用操作系统或者浏览器的CA公钥，解密服务器证书，查看是否一致
   3. 如果没问题，就取出服务器的公钥，使用它来加密本次报文
   4. 确定使用的加密算法
   5. 然后生成第三个随机数
4. 服务器最后回应：
   1. 服务器用自己私钥解密发来的报文，拿到第三个随机数
   2. 此时客户端和服务器都有三个随机数
   3. 客户端和服务器使用协商好的加密算法生成会话密钥。之后就用会话密钥进行加密报文。
   4. 最后使用会话密钥将以上所有信息做一个摘要加密，发给客户端，用于给客户端验证。

#### 如果由中转服务器劫持，当一个中间人这样还安全吗。

1. 这样https前提是中间人会将自己的CA证书发给客户端，此时浏览器CA解密后，会提示这个证书不安全，是伪造的。


### http /2 基于https更安全，头部字段压缩，如果发送多个请求，报文头是一样的或者是相似的，会消除重复部分。内容不再是1.0纯文本格式的报文，全部采用二进制，都是二进制。统称为帧，传输效率更高。并发传输，提出stream的概念，多个stream复用在一个tcp连接。不同http请求由不同的streamid，接收端可以根据streamid将乱序的http消息排序好。
1. 虽然stream概念解决了http层对头阻塞，但下层采用tcp协议，基于字节流，当前一个字节数据没到，整个数据只能当在内核缓冲中，http2.0应用层才能从内核中拿到全部数据，这就是队头阻塞问题。