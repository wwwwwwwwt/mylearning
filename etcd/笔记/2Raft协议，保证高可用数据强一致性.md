<!--
 * @Author: zzzzztw
 * @Date: 2023-05-20 11:04:47
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-05-20 15:04:56
 * @FilePath: /myLearning/etcd/笔记/2Raft协议，保证高可用数据强一致性.md
-->
# raft一致性协议保证高可用一致性

### 主流基于主从复制的同步方案例如mysql/redis主要强调的是最终一致性，raft共识算法相当于定义一套规则，当出现情况时各个节点都能用这套规则进行协商最终得到在这个情况一致的决策，实现各个节点的一致性，CAP理论，一套分布式系统只能在一致性，可用性，分区容错性三个中满足两个。一般为一致性和可用性直接抉择。

### raft算法分为leader选举，日志复制，安全检查三个小部分

### leader选举
* 节点状态分为三种，leader（集群领导者，拥有想从节点同步自身日志的权力，需要定时通过发送心跳给从节点，维持自己在线leader的状态）， 竞选者（有变成leader的资格，收到大多数节点的支持后就变为leader）， 从节点（同步接受leader发来的日志，当超时了就会变为竞选者）
* 每个leader有自己独一无二且单调递增的任期号，用于比较各个节点的数据新旧和识别过期的leader。
* 每个从节点都只有一票的权力，不能同时投给多个节点。

#### 大体流程
1. 一开始初始化无leader状态，每个节点都是从节点，都有一点点随机数误差，导致不同的开始计时时间，超时就变成竞选者，首先为自己投票，再向其他节点发送广播，请求他们为自己投票，如果收到广播的这个节点还没有投票，那么通过一定验证后，他将投票给请求的那个节点，自身节点重置自己的超时时间。
2. 竞选者得到大多数节点的票后，成为leadere向其他节点同步自己的日志，直到leader发生异常
3. 如果leader下线了。每个节点有细微的过期时间，首先过期的成为候选者向其他节点发心跳 重复1，2；如果两个节点同时过期，那么将可能平手或者一个节点日志比较新都投给这个节点了，或者这个节点日志落后于自己不给他投票。经过一轮投票后如果平手，那么所有节点超时时间重置将开始第二轮选举。

#### 异常情况详解

1. ABC三个节点，A下线了，先到期的B成为候选者，先自增任期号投票给自己，再广播请求，C收到后，确定B的数据至少和自己一样新，B的任期号大于C当前日志中记录的leader任期号，并且C没投票给其他节点，然后给他投票，B成为Leader。
2. 如果C也同时过期，那么两个节点都投票给自己，都不能超过一半节点支持，都不能成为leader，重置过期时间等下一轮。
3. 新leader选举出来后，就leader如果发现了新leader并看到他的任期比自己新，这个旧的leader就成为了从节点。

### 日志复制
* client向leader发送一个put操作，首先leader接受，并更新这个日志，把做好的日志发给每个从节点，并更新自己的wal日志。从节点更新，更新的不一定是这个日志，有可能是之前的类似一个队列，从节点更新完成发给leader这个日志更新好了，然后这个日志有大于一半节点都更新自己日志wal好了，leader就把这个日志标记为commit。
* 日志内容包括leader的任期号和日志索引号，从节点返回给leader的报文有自己更新到的日志号。
* 节点之间的广播通过http协议交流，进行leader选举，raft算法实现日志复制等通信。


### 安全性

* 由只附加和日志匹配特性保证。
* 只附加不删除：leader只能追加日志，不能删除已经持久化的日志
* 日志匹配，新leader上任后，会将前任剩下的自己还没提交的日志提交完，再发送新的日志给其他节点。