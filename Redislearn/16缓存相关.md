<!--
 * @Author: zzzzztw
 * @Date: 2023-05-10 21:14:53
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-05-11 18:44:36
 * @FilePath: /myLearning/Redislearn/16缓存相关.md
-->
# 1. redis用作缓存相关

1. 缓存的特征：一个系统不同层之间的访问速度不一样，所以我们才需要缓存，这样就可以把一些常用访问的数据放在缓存中，加快访问速度
2. cpu 20 - 40 ns 1 - 32mb， 内存 100ns 32 - 96GB，磁盘3 - 5ms， 1 - 4TB
3. 计算机系统中默认两种缓存，1.LLC->l3级别高速缓存，2.内存中高速缓存页
4. 缓存容量是很有限的，达到一定容量时需要一定的算法将一些缓存淘汰出去。

### redis处理缓存的两种情况
1. 缓存命中直接返回数据
2. 缓存缺失，需要从数据库中读取数据，在更新到数据库中。还会涉及到缓存和数据库中一致性的问题。

### redis常用作旁路缓存，即不是计算机系统内的缓存。

### redis作为缓存的类型，可以分为只读缓存和读写缓存。

1. 只读缓存：顾名思义，修改与增加key不在redis中进行，数据库中删掉一条key的时候需要同步的把缓存中的key也删除，数据库修改key的时候，需要也需要redis把key删除掉，再查找时发生缓存缺失再重新数据库中读取。
- 数据缓存的好处，所有最新数据都在数据库中，数据不会有丢失风险。
2. 读写缓存：读写操作全在redis中进行，然后根据业务进行同步写回和异步写回。同步写回时写入redis同时一起写回数据库相比之下更安全，异步写回直到redis缓存写满了才把请求写回数据库，效率高但一旦redis宕机就丢失数据。 

# 2. redis缓存满了怎么办

- 一般建议缓存容量为总数据量的15% - 30%
  
1. 缓存数据淘汰机制：
  - 不进行淘汰，redis默认不会淘汰，满了会报错
  - 设置过期时间的数据中进行淘汰，volatile-random， ttl（根据设定过期时间的键值对先后）， lru， lfu
  - 在所有数据中进行淘汰，allkeys-random lru， lfu
  - 一般来说建议allkeys-lru，适合冷热鲜明的数据。

# 3. 如何解决缓存和数据库数据不一致问题

- 读写缓存只需要同步写回数据就能保证数据库和缓存的数据一致！！！！前提是这个操作是原子操作。
- 只读缓存，新增key只在数据库增加，不影响，删改的情况需要讨论：
- 结论！！！，基于重试机制先删数据库，再删缓存。
- 重试机制：利用消息队列将删除的消息先保存下来，如果没能删除缓存值，就将消息队列消息取出继续删

- 大并发情况下，即使删缓存和删数据库都没报错，也可能会别的线程读到旧值，解决方法如下：
  - 首先很难保证100%一致，需要在性能和一致性之间取到一个权衡
  - 先删数据库再删缓存会比较好，这样即使少部分线程取到旧的值，等到本机缓存删除后，大部分线程发现没命中key还可以从数据库读到新的值。
  - 如果先删缓存，并发度足够高的话可能这一轮所有线程都返回旧的值
  - 还有一个策略是根据业务和线程速度，来进行延迟队列的操作，使删缓存和删数据库都删完了，在让别的线程进来。

# 4. 缓存雪崩，缓存击穿，缓存穿透

- 缓存雪崩：大量请求无法再redis缓存中进行处理，从而直接发送给数据库，导致数据库层面压力过大。
  - 原因：1. 缓存中同时有大量的key进行过期，导致每个key都需要从数据库重新读取 2. redis宕机了。
  - 解决方案：1.微调过期时间：给每个key设置一定范围内随机的过期时间，如随即增加1 - 3分钟。2. 发生雪崩时，进行服务降级，使核心key得到请求，非核心返回预设的信息。3. 宕机了，在业务中设置熔断限流，暂停对缓存服务的访问，等到redis服务再上线再开。
- 缓存击穿：对访问非常频繁的key，过期了，导致并发访问的很多请求一下子发到服务器拉取新值，导致服务器压力过大。
  - 解决方案：将热点key设置没有过期时间，或使用哈希和锁机制，每次只有一个线程进去获取值，其他线程等待这个线程获取到值后直接返回
- 缓存穿透：指查询的数据不在redis中也不再数据库中，导致每次查询都会从数据库中找然后返回没有，给缓存和数据库带来很大压力
  - 解决方法：1.提供空值或缺省值，下次返回这个。2.设置布隆过滤器，类似于多重状态压缩，通过n个哈希函数映射到bit都为1才证明存在，有误判的可能，需要上层业务支持，。3.上层业务判断合法。


# 5. 三种缓存问题解决方案总结：

- 缓存雪崩：合理设置key过期时间，搭建高可靠集群防止实例掉线
- 缓存击穿：热点key不设置过期时间，或使用哈希和锁机制保证只有一个线程取拉去数值，其他线程直接拿这个值返回。
- 缓存穿透：设置空值，设置布隆过滤器，上层业务判断是否合法。