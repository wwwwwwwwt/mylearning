<!--
 * @Author: zzzzztw
 * @Date: 2023-04-20 19:45:18
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-04-20 21:55:48
 * @FilePath: /myLearning/Redislearn/13Redis中的异步机制，避免单线程模型阻塞.md
-->
# 异步机制：如何避免单线程模型的阻塞？

1. 由于Redis支持高性能访问，所以我们在使用时必须重视影响性能得因素，可能影响Redis性能得五大潜在因素分别是
   * Redis内部的阻塞式操作
   * CPU核和NUMA架构的影响
   * Redis关键系统配置
   * Redis内存碎片
   * Redis缓冲区

2. Redis内部阻塞点：Redis网络io和对键值对的读写时由主线程单线程完成的，所以主线程阻塞将导致性能大幅度下降。
   * 客户端：网络io，键值对增删改查，数据库操作
   * 磁盘:生成RDB快照，记录AOF日志，AOF日志重写操作
   * 主从节点：主库选举，传输RDB文件，从库接受RDB文件，加载RDB文件，清空数据库
   * 切片集群实例：传输哈希槽信息，数据迁移

<center>

![](img/13(1).png)

</center>

## 和客户端交互的阻塞点

1. 对键值对的增删改查，一旦涉及到O(n)就需要引起注意了，比如集合的全查查询和聚合操作
2. 删除操作：删除操作的本质是释放键值对所占用的内存空间，这个时候物理页是被锁住的，并且释放掉的内存还需要插入空闲内存块的链表。这个过程需要一定时间，并且会释放当前内存的应用程序，所以一下子释放大量内存，操作空闲链表的操作时间就会增加，造成主线程Redis主线程的阻塞。什么时候会释放大量内存：bigkey操作，删除含有大量元素的集合就是这种情景。
3. 清空数据库，和第二点一样，设计删除和释放所有的键值对。

## 和磁盘交互的阻塞点

1. 磁盘IO费时费力，所以生成RDB快照和AOF日志重写都是由子线程执行。但是当重写AOF日志进行fork时一定会阻塞主线程，还有如果在重写时主线程更改了一个bigkey操作重写需要写拷贝操作申请一块内存来进行主线程子线程页空间分离时，也会阻塞主线程。（AOF重写会阻塞）

## 主从节点交互时阻塞

1. 主从复制时，创建和传输RDB文件都由子线程进行不会阻塞主线程，但对于从库来说，接受RDB时需要清空当前数据库，会阻塞，之后的加载RDB速度取决于RDB的大小，也会阻塞

## 切片集群实例交互时阻塞

1. 部署 Redis 切片集群时，每个 Redis 实例上分配的哈希槽信息需要在不同实例间进行传递，同时，当需要进行负载均衡或者有实例增删时，数据会在不同的实例间进行迁移。不过，哈希槽的信息量不大，而数据迁移是渐进式执行的，所以，一般来说，这两类操作对 Redis 主线程的阻塞风险不大。（切片集群实例间的负载均衡时，进行哈希槽的传递）
2. 采用Redis cluster方案，只要不是迁移bigkey基本都不会阻塞。

## 总结阻塞点：

1. 集合全量查询和聚合操作
2. bigkey删除
3. 清空数据库
4. AOF重写日志
5. 从库加载RDB文件