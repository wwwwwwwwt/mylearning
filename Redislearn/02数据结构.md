<!--
 * @Author: zzzzztw
 * @Date: 2023-03-01 22:18:14
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-04-19 15:44:58
 * @FilePath: /myLearning/Redislearn/02数据结构.md
-->
# 快速的Redis有哪些慢操作

1. 快的原因采用了Redis使用了一个全局哈希表来保存存有键值对（储存的是键值的指针），我们可以使用O(1)的时间复杂度来快速查找键值对，只需要计算哈希值。
2. 当往哈希表中写入很多数据时，哈希冲突是不可避免的，哈希冲突指根据哈希计算后两个key落在了一个哈希桶里，解决哈希冲突的方式就是链式哈希，指同一个哈希桶中多个元素用一个链表来存，当哈希冲突很大时，退化成o(n).
<center>

![](./img/02(1).png)
</center>
2. 所以，Redis会进行rehash操作，rehash就是桶分裂成两倍，然后重新计算哈希值映射到新桶，在将原来的桶清空。第二部重新映射涉及大量数据拷贝，一次性都拷贝过去会造成Redis线程的阻塞，所以采用渐进式rehash,每处理一个请求就从哈希表第一个索引位置将这个位置的元素拷贝到新桶，等处理下一个请求时，再对下一个索引进行处理。将开销分摊到了多次处理请求中，保证数据的快速访问。
<center>

![](./img/02(2).png)
</center>

3. 集合数据操作效率
底层数据结构有五种，整数数组，双向链表，哈希表，压缩列表（字节数组）和跳表。  
整数数组和双向链表操作复杂度均是O(n),哈希表O(1),压缩列表有三个字段，长度，尾部偏移量压缩列表中的个数，查找头尾是O(1),其他O(n)。  
跳表：
<center>

![](./img/02(3).png)
</center>
在链表间建立一级索引/二级索引/.../ 数据量很大时跳表复杂度为O(logN)

## 总结
1. 基本数据类型: String，hash， set， sorted set, list
2. 对于单元素增删改查:每一种集合类型对于但数据的增删改查的复杂度，HEGT,HSET,HDEL如hash为O(1)，同时操作M个元素，复杂度等于单个复杂度乘元素数。
3. 范围操作，指集合中的遍历操作，复杂度一般是o(N)
4. 统计操作，指集合类型中所有元素的个数同济，一般O(1)
5. 例外，对于压缩列表和双向链表的头尾插入，如对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。