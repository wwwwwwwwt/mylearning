<!--
 * @Author: zzzzztw
 * @Date: 2023-04-03 14:50:17
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-04-17 15:29:00
 * @FilePath: /cpptest/c++面试八股文/c++基础.md
-->
# 1.为什么要用智能指针
答：
* 为了防止使用原生的new后忘记delete而造成内存泄漏的问题，其原理是RAII，即在构造函数时分配资源，在析构函数时释放资源。
* 常用接口
```cpp
T* get() //获得原生指针
T& operator*()//重载取值
T* operator->()//重载箭头取取成员函数 相当于* .
T* release()//清空当前指针，返回清空前指向的地址

```

* 常用智能指针
* 1. auto_ptr 已经废弃，原因是它支持拷贝构造和拷贝赋值，在使用时不经意间会导致对象被变为野指针
* 2. unique_ptr auto_ptr的改进，显示的声明移动构造和移动赋值，相当于删除了拷贝构造和拷贝赋值，在使用时需要显示的声明右值引用才行，表明我们已经知道这样做会导致对象所有权的转移
* shared_ptr 引用了引用计数，内部底层由T* ptr的数据指针和一个计数类shared_count类的指针（管理着引用计数和弱指针的一些）组成，只有当引用计数归零时才会释放数据指针。
* weak_ptr 为了解决shared_ptr互相引用而导致计数永远不可能为0的情况，因为他的构造函数和析构函数不会造成计数的增加或减少，只能由shared_ptr 和weak_ptr转换得到

# 2.c++中内存分配的情况
1. 栈：存放局部变量和函数参数，由编译器管理分配和回收
2. 堆：自己管理 使用new / delete 进行分配和回收，但可能出现内存泄露
3. 全局/静态存储区：分为已初始化和未初始化的区域，分别存放已初始化和未初始化的全局变量和静态变量
4. 常量存储区：存放常量或字面值常量
5. 代码区：存放程序的二进制代码
```cpp
#include <iostream>
using namespace std;
/*
说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中
*/
int g_var = 0; // g_var 在全局区（.data 段）
char *gp_var;  // gp_var 在全局区（.bss 段）

int main()
{
    int var;                    // var 在栈区
    char *p_var;                // p_var 在栈区
    char arr[] = "abc";         // arr 为数组变量，存储在栈区；"abc"为字符串常量，存储在常量区
    char *p_var1 = "123456";    // p_var1 在栈区；"123456"为字符串常量，存储在常量区
    static int s_var = 0;       // s_var 为静态变量，存在静态存储区（.data 段）
    p_var = (char *)malloc(10); // 分配得来的 10 个字节的区域在堆区
    free(p_var);
    return 0;
}
```


# 3.c++函数中按指针传参和按引用传参
1. 不同点：引用传参为间接寻址，直接操作本体；按指针传参实际上还是传入的本体指针的副本，在函数体内对指针的操作不影响原指针，除非传入指针的指针或指针引用。
```cpp

#include <bits/stdc++.h>
using namespace std;

void func(int *p , int *t){
    p = t;
}

int main(){

    int* p = new int[15];
    int* t = new int[23];

    cout<<p<<"     "<<t<<endl;

    func(p,t);

    cout<<p<<"     "<<t<<endl;

    delete[] t;
    delete[] p;
    return 0;
}

输出：
0x5571b0e41eb0     0x5571b0e41f00
0x5571b0e41eb0     0x5571b0e41f00

改为引用的话就改变了地址，但delete []需要修改,因为指向同一块内存。两次delete[]同一块内存未定义行为报错
0x560bfcd54eb0     0x560bfcd54f00
0x560bfcd54f00     0x560bfcd54f00
```

# 4. c++ static 关键字和 const 关键字
## static
* 修饰局部变量：延长其生命周期，将其放在静态区中，与程序的生命周期相同，但作用域没变，作用域还是限定在语句块
* 修饰全局变量或函数： 改变作用域，由全工程可见变为本文件可见
* 修饰类：对类中某个函数使用static 表示这个函数不属于任何这个类的对象，而是整个类共用；如果类中某个变量进行static修饰，表示该变量为所有对象共用一个，存储空间只存在一个副本，可以通过类的对象调用，静态非常量数据成员只能在类外定义和初始化，在类内只能声明。
* static 类对象必须要在类外进⾏初始化，static 修饰的变量先于对象存在，所以 static 修饰的变量要在类外初
始化；
* 由于 static 修饰的类成员属于类，不属于对象，因此 static 类成员函数是没有 this 指针，this 指针是指向本
对象的指针，正因为没有 this 指针，所以 static 类成员函数不能访问⾮ static 的类成员，只能访问 static修饰
的类成员；
* static 成员函数不能被 virtual 修饰，static 成员不属于任何对象或实例，所以加上 virtual 没有任何实际意
义；静态成员函数没有 this 指针，虚函数的实现是为每⼀个对象分配⼀个 vptr 指针，⽽ vptr 是通过 this 指
针调⽤的，所以不能为 virtual；虚函数的调⽤关系，this->vptr->ctable->virtual function
```cpp

class A
{  
private:
    static int count ; // 类内声明
};

int A::count = 0 ; // 类外初始化，不必再加static关键字
---------------------------------------------------
class A
{  
private:
    static const int count = 0; // 静态常量成员可以在类内初始化
};

```

## const
* const 修饰基本类型数据类型：基本数据类型，修饰符 const 可以⽤在类型说明符前，也可以⽤在类型说明符后，其结果是⼀样的。
* const 修饰指针变量和引用变量，const 在\*左侧表示指针指向的值不能变， const在\*右侧表示指针指向的地址不能变
* const 在类中， const成员变量只能使用构造函数初始化列表的方式进行初始化。

# 5. C和C++区别
* c++新增关键字等：new delete auto explicit
* c++有函数重载的的概念（静态多态），c语言不能出现同名函数， c++有虚函数概念（动态多态），用来实现多态。
* c语言中strcut中不可以有成员函数，只能有成员变量， c++中都可以有，并且c++有class类这个概念，与strcut不同为struct默认pulic class默认private
* c语言没有模板函数概念，如果实现必须用到宏，c++有模板函数概念，提高了函数的复用
* c++提供stl标准库和容器

# 6. 说一下c++中怎么定义常量，常量存放在哪个区域
* 局部常量存在栈中
* 全局常量编译器不分配内存，放在符号表中提高访问速度
* 字面值常量存放在常量区


# 7. c++中重载和重写有什么区别
  
* 重载：overload，表示同一可访问区被声明的几个具有不同参数列表的同名函数，依赖于c++函数名字的修饰会将参数加在后面，可以是参数类型，个数，顺序的不同，根据参数列表决定调用哪个类型，C++中函数重载要求函数名相同但函数参数列表不同。重载不关心函数的返回类型。如果两个函数只有返回值不同，算是函数重定义，在同一个作用域内不能有两个具有相同名称和参数列表的函数

* 重写：override, 表示在派生类中重新定义父类除了函数体外完全相同的虚函数（virtual 函数），注意被重写的函数不能是static的，一定得是虚函数，并且函数名字，参数列表，返回值需要完全一样。子类和基类都共享一个静态函数和静态成员变量。

* 重定义：派生类中重新定义父类中相同名字的非虚函数，参数列表和返回类型都可以不同，即父类中除了定义成virtual且完全相同的同名函数才不会被派生类中的重名函数所隐藏（重定义）。一般应该避免这种，造成混淆和可阅读性下降。

# 8. c++所有的构造函数
1. 无参数构造函数 ( 默认构造函数 )：编译器会自动生成，如果不想使用编译器自动生成的，就需要自己显示的写一个
2. 一般构造函数：也称重载构造函数，一个类可以有多种重载构造函数，前提是参数的个数或类型不同
3. 拷贝构造函数：拷贝构造函数的函数参数为这个类另一个对象的常引用，用于根据一个已经存在的对象复制出一个新的该类的对象，将已经存在的对象的数据成员的值一一复制到新创建的对象中。当类中有指针成员函数时，必须自己定义拷贝构造函数，防止默认的复制构造函数是浅拷贝。
4. 移动构造函数：函数参数为这个类的另一个对象的右值引用，用于交换对象的所有权，常见于unique_ptr的实现 / 使用右值直接在类上构造。
5. 类型转换构造函数： 根据一个别的类型的对象创建一个本类型的对象，如果不想让编译器进行隐式转换的话，需要在构造函数前声明explicit
6. 赋值运算符的重载：一般来说参数推荐按值传递。注意，等号左右对象必须是已经存在的才走赋值运算符， 如果等号左边正在初始化，走拷贝构造函数。

# 9. c++ 4种强制转换

c++的四种强制转换包括：static_cast<T>(), dynamic_cast<T>(), const_cast<T>(), reinterpret_cast<T>()
* static_cast: 明确指出类型转换，没有动态类型检查，所以上行转换安全，（派生类转换为基类安全）， 下行转换不安全，（基类转换为派生类），主要用于执行非多态的转换操作。
* dynamic_cast: 专门用于派生类之间的转换，T 必须为类指针，类引用 或 void* ，对于下行转换是安全的，当类型不一致时，转换过来的的为空指针。如果时static_cast转换过来的错误意义的指针，可能造成非法访问。
* const_cast: 用于const属性的转换，比如给有const修饰的类型去除const 或 无const修饰的加上const
* reinterpret_cast: 一般不使用，高危操作，从底层对数据类型重新解释，可以将整形转换为指针，将指针转换为数组，将指针和引用互相转换。

# 10. 指针和引用的区别
* 区别1：指针是一个实体，引用只是一个原对象的别名
* 区别2：指针指向一块内存，指针的值就是指向内存的地址，编译时，将指针变量名和指针变量的地址添加到符号表中，指针的内容是可以改变的，有const和非const之分。引用只是一块内存的别名，编译时将引用变量名和引用对象的地址添加到符号表符号表一经完成不可修改，所以引用必须只能在定义是绑定到已经存在的一块内存上，后续就不可以再修改了，也没const和非const之分
* 区别3：sizeof 指针得到的是指针本身的大小 32位是4 字节， 64 位是8字节，sizeof引用得到的是原对象的大小。
* 区别4： 作为参数是，传入指针是传入原指针地址的拷贝，在函数内部修改指针指向不会造成原指针的变化，改变指针的值会变化；引用传入的是原对象的地址。

# 11. 野指针和悬空指针有什么区别？如何避免？

* 野指针：没有被初始化过的指针
* 悬空指针：一开始指向一块分配的内存，但后来被释放的指针。
* 无论野指针还是悬空指针都指向一块无效的内存空间，访问这个内存空间会导致未定义行为

# 12. 说一下const修饰的指针如何区分？

```
1. *号左边都代表修饰指针指向的对象，表示这个指针指向的值不可变 const int * val;
2. *号右边都代表修饰指针，表示这个指针的地址不可以被改变 int * const val;
3. 两边都有表示值不可变，地址也不可变。const int* const val;

```

# 13. 简单说一下函数指针

*  首先是定义：函数指针是指向函数的指针变量，函数指针首先自己是一个指针变量，该指针变量指向一个具体的函数。
*  编译时，每一个函数都有一个入口地址，该入口地址就是函数指针指向的地址，有了指向函数的指针变量后，可以用这个指针调用该函数。

```cpp
void func(char* p) {....}

void (*pf)(char* p){....}

pf = func;//函数指针pf指向函数func
pf(p);//通过函数指针pf调用函数func

```

# 14. 堆和栈的区别

1.  栈：
* 编译器自动分配，连续的内存空间， 大多数编译器，函数的参数都是从右向左入栈，这样方便可变参数模板那个特性，第一个函数数量的参数会被放在栈顶，方便解析。函数调用后，局部变量先出栈，然后是参数，最后是栈顶函数指针。

2. 堆
* 程序员自动分配，new malloc/ delete free分配 ，不释放会造成内存泄漏。不连续的内存空间，实际上内存中有一个空闲内存的链表，当有程序申请时，会遍历空闲链表找到第一个大于等于申请大小的内存空间，一般分配内存大小是，会将对象数量写入空间的头部， delete []时会先访问这块空间的头部，得到需要析构对象的数量，再依次执行析构函数。

# 15. 函数传递参数有几种方式

答：3种，按值传递，按指针传递， 按引用传递

* 按值传递，实际上是实参的拷贝，在函数内部对这个参数进行的操作不会影响到外部
* 按指针传递，也是按值传递的一种，只不过是原来值地址的拷贝，对这块地址进行操作时，会影响外部参数的值的变化，不过对于这个指针指向的操作不会影响外部实参
* 按引用传递，实际上就是把引用对象的地址放在函数的栈空间内，对函数内形参的任何操作都可以影响外部实参。

# 16. new/delete, malloc/free区别

1. 共同点：都可以用来在堆上分配内存。
2. new/delete是操作符，malloc/free是库函数。
3. new自动计算需要的空间大小，malloc需要手动计算。
4. new 返回对象指针，malloc返回void* 地址内存
5. new可以自动调用对象的构造函数，malloc需要手动在分配好的内存上进行构造对象。
6. 执行new的过程：1. new会先使用operator::new（对底层函数malloc的封装，为的是在c++中，用户可以在类中重载operator：：new这个函数）函数在堆上分配内存。2. 在分配好的内存上调用对象的构造函数。 3. 返回指针    
7. delete同理。

# 17. volatile 和 extern 关键词

1. volatile: 不可优化性：告诉编译器不要对这个变量进行任何优化，甚至会将这个变量优化没，保证写的指令一定按指令的原来意思来执行。
2. volatile：在多线程中的共享变量中，最好加上volatile，目的是让编译器每次都从内存中加载出这个变量的最新值，否则可能编译器直接从缓存中读取，不是最新值。
3. extern: 
   1. C语言中，extern表示这个变量或函数在别处定义过了，在此处引用
   2. c++中，如果c++调用了c库函数，需要在extern “C”声明引用的函数，主要原因是c++和c编译完成后在目标代码中的命名规则不同，用来解决名字匹配问题。

# 18. typedef，using ，define 和 const 区别（编译阶段，安全性，内存占用） 

* define的坑：define  p int* 在 p a,b 这样时，只有a为整型指针，b为int， 相当于 int* a， b
* 替换为 typedef int* p . p a,b时a b 均为整形指针

* define 在程序的预编译期进行处理 
* typedef 和 using 都在程序运行期
1. 基本用法：
   * #define 新名称 已知名称
   * typedef 已知名称 新名称    typedef void(*p)(int，char) 声明一个函数指针 p pa；
   * using 新名词 = 已知名称


# 19. 计算下面几个类的大小


```cpp

class A{}; // 空类大小为1，为了得到占位的地址

class A{virtual Fun(){}}; // 带有虚函数的类，都会在类的大小上加上一个虚指针的大小，32位4字节， 64位8字节

class A{static int a = 1;} // 大小为 1和空类一样 静态变量不在对象中存储中，

class A{int a;} // 大小为 4

class A{int a; double b;} //大小为16，内存补齐

```


# 20. 面向对象的三大特性，举例说明 

1. 面向对象三大特性: 封装， 继承， 多态
2. 封装：把客观事务封装成抽象的类，并且可以设定不同的隔离级别，封装对象内部实行保护，用户只能使用暴露出来的接口来进行操作。
3. 继承：子类继承了父类的一些方法和成员变量，继承的过程就是一般到特殊的过程。
4. 多态：分为静态多态和动态多态，静态多态就是函数的重载，在编译期间已经决定了将调用哪个函数，所以叫静态多态。 动态多态就是基类有虚函数，子类通过继承基类，重写虚函数来实现动态多态,通过使用基类的指针，指向不同的派生类，同一个虚函数/接口，可以展现出不同的方法。动态多态在运行期间根据虚函数表决定调用哪个函数，成为动态多态。

# 21. 多态的实现

1. 静态多态：通过函数的重载
2. 动态多态：继承 + 虚函数 + 虚函数表 + 虚函数指针。
3. 子类继承父类时，父类的纯虚函数必须重写，否则子类也是一个虚类不可以实例化。 


# 22. 虚函数表，虚函数指针，虚函数的实现原理

1. 虚函数表：编译期生成，编译器会检查子类有没有对父类的虚函数进行重写，如果重写了将这个虚函数地址替换成子类的，然后检查自身的新增虚函数，如果有也放进虚函数表
2. 虚函数指针：运行期生成，因为虚函数指针是基于对象的。指向虚函数表
3. 基类指针指向了派生类，再调用虚方法发生了什么：首先指针指向了虚指针的位置，调用方法，实际上是调用了这个指针的一个偏移量，由于派生类和父类虚函数在虚函数表内部的偏移量是相同的，所以将调用派生类虚函数表内的虚函数，这样产生了多态。如果是指向基类，那么先得到基类的虚函数指针，再偏移，调用的就是基类的方法。 


# 23. 编译期如何处理派生类虚函数

1. 拷贝基类的虚函数表，如果有多个继承，派生类就不止一个虚函数表，每继承一个就多一个虚函数表。
2. 一般继承的第一个是主基类。
3. 检查派生类中有没有重写基类的虚函数，重写了就替换成派生类自己重写后的地址。将派生类自身的新增虚函数添加到主基类虚函数表内。
4. 注意，多重继承的子类内存布局是，虚函数表指针1 + 主基类成员 + 派生类成员 + 虚函数表指针2 + 第二个基类成员 + 虚函数表指针3.。。。。 这样布局为了确保派生类内虚函数偏移量基类相同。

# 24. 析构函数一般都写成虚函数，构造函数不能写为虚函数。

1. 析构函数一般都写成虚函数目的是降低内存泄露的风险，如果不是虚函数将调用基类的虚函数，如果是虚函数，先将调用指向对象的虚函数，再调用基类的析构函数。
2. 编译期实现虚函数指针的方式是现有对象再有虚函数指针，如果是虚构造函数，就违反了这个原则。


# 25. 构造函数的执行顺序和析构函数的执行顺序

* 构造时先构造基类，析构先析构派生类

1. 构造函数：基类构造函数 - 成员对象构造函数 - 派生类构造函数
2. 析构函数（需要是虚析构函数）： 派生类析构函数- 成员对象构造函数 - 基类构造函数 

# 26. 构造函数和析构函数中调用虚函数会怎样

* 是一种未定义行为，因为构造时会先使用基类的构造，当创建派生类对象时，派生类自身部分还没有被初始化。

# 27. 纯虚函数（用于接口继承和实现继承）

1. 函数内有形如virtual void func() = 0的函数时，这个函数叫纯虚函数，这个类叫抽象类
2. 抽象类不可以生成实例对象，但可以声明指针，作用类似于基类指针，指向派生类，调用其内部的虚函数接口
3. 继承于抽象类后，每个派生类都必须强制的重写纯虚函数，否则这个派生类也将是抽象类，不可以生成实例对象。

# 28. 深拷贝和浅拷贝

1. 当出现等号赋值时会调用拷贝函数，未显示的定义拷贝函数时，默认的拷贝函数时浅拷贝的，即完成成员的一一复制。当成员变量没有指针时是可以的，但是有指针的情况下，会使两个指针指向同一块内存地址，就会出现修改指针的值时会影响到其他对象，并且可能会提前析构，导致其他对象产生野指针或析构两次内存未定义的问题。
2. 所以当成员变量中有指针时，应使用深拷贝，即在堆内存中申请空间来复制指针所指向的内存的内容。

# 29. 为什么拷贝构造函数必须按引用传递，不能像赋值运算符一样按值传递

1. 防止递归调用无限生成临时对象。

# 30. 为什么要进行内存对齐

1. 内存对齐规则：小的成员要凑成大的成员的内存的倍数，少的要用空闲内存补上
2. 作用：
   * cpu的内存访问速度大大提升， 按块访问，而不是读取多个字节
   * 有利于代码的移植