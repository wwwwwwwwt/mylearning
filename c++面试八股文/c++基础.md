<!--
 * @Author: zzzzztw
 * @Date: 2023-04-03 14:50:17
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-04-07 14:09:22
 * @FilePath: /cpptest/c++面试八股文/c++基础.md
-->
# 1.为什么要用智能指针
答：
* 为了防止使用原生的new后忘记delete而造成内存泄漏的问题，其原理是RAII，即在构造函数时分配资源，在析构函数时释放资源。
* 常用接口
```cpp
T* get() //获得原生指针
T& operator*()//重载取值
T* operator->()//重载箭头取取成员函数 相当于* .
T* release()//清空当前指针，返回清空前指向的地址

```

* 常用智能指针
* 1. auto_ptr 已经废弃，原因是它支持拷贝构造和拷贝赋值，在使用时不经意间会导致对象被变为野指针
* 2. unique_ptr auto_ptr的改进，显示的声明移动构造和移动赋值，相当于删除了拷贝构造和拷贝赋值，在使用时需要显示的声明右值引用才行，表明我们已经知道这样做会导致对象所有权的转移
* shared_ptr 引用了引用计数，内部底层由T* ptr的数据指针和一个计数类shared_count类的指针（管理着引用计数和弱指针的一些）组成，只有当引用计数归零时才会释放数据指针。
* weak_ptr 为了解决shared_ptr互相引用而导致计数永远不可能为0的情况，因为他的构造函数和析构函数不会造成计数的增加或减少，只能由shared_ptr 和weak_ptr转换得到

# 2.c++中内存分配的情况
1. 栈：存放局部变量和函数参数，由编译器管理分配和回收
2. 堆：自己管理 使用new / delete 进行分配和回收，但可能出现内存泄露
3. 全局/静态存储区：分为已初始化和未初始化的区域，分别存放已初始化和未初始化的全局变量和静态变量
4. 常量存储区：存放常量或字面值常量
5. 代码区：存放程序的二进制代码
```cpp
#include <iostream>
using namespace std;
/*
说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中
*/
int g_var = 0; // g_var 在全局区（.data 段）
char *gp_var;  // gp_var 在全局区（.bss 段）

int main()
{
    int var;                    // var 在栈区
    char *p_var;                // p_var 在栈区
    char arr[] = "abc";         // arr 为数组变量，存储在栈区；"abc"为字符串常量，存储在常量区
    char *p_var1 = "123456";    // p_var1 在栈区；"123456"为字符串常量，存储在常量区
    static int s_var = 0;       // s_var 为静态变量，存在静态存储区（.data 段）
    p_var = (char *)malloc(10); // 分配得来的 10 个字节的区域在堆区
    free(p_var);
    return 0;
}
```


# 3.c++函数中按指针传参和按引用传参
1. 不同点：引用传参为间接寻址，直接操作本体；按指针传参实际上还是传入的本体指针的副本，在函数体内对指针的操作不影响原指针，除非传入指针的指针或指针引用。
```cpp

#include <bits/stdc++.h>
using namespace std;

void func(int *p , int *t){
    p = t;
}

int main(){

    int* p = new int[15];
    int* t = new int[23];

    cout<<p<<"     "<<t<<endl;

    func(p,t);

    cout<<p<<"     "<<t<<endl;

    delete[] t;
    delete[] p;
    return 0;
}

输出：
0x5571b0e41eb0     0x5571b0e41f00
0x5571b0e41eb0     0x5571b0e41f00

改为引用的话就改变了地址，但delete []需要修改,因为指向同一块内存。两次delete[]同一块内存未定义行为报错
0x560bfcd54eb0     0x560bfcd54f00
0x560bfcd54f00     0x560bfcd54f00
```

# 4. c++ static 关键字和 const 关键字
## static
* 修饰局部变量：延长其生命周期，将其放在静态区中，与程序的生命周期相同，但作用域没变，作用域还是限定在语句块
* 修饰全局变量或函数： 改变作用域，由全工程可见变为本文件可见
* 修饰类：对类中某个函数使用static 表示这个函数不属于任何这个类的对象，而是整个类共用；如果类中某个变量进行static修饰，表示该变量为所有对象共用一个，存储空间只存在一个副本，可以通过类的对象调用，静态非常量数据成员只能在类外定义和初始化，在类内只能声明。
* static 类对象必须要在类外进⾏初始化，static 修饰的变ᰁ先于对象存在，所以 static 修饰的变ᰁ要在类外初
始化；
* 由于 static 修饰的类成员属于类，不属于对象，因此 static 类成员函数是没有 this 指针，this 指针是指向本
对象的指针，正因为没有 this 指针，所以 static 类成员函数不能访问⾮ static 的类成员，只能访问 static修饰
的类成员；
* static 成员函数不能被 virtual 修饰，static 成员不属于任何对象或实例，所以加上 virtual 没有任何实际意
义；静态成员函数没有 this 指针，虚函数的实现是为每⼀个对象分配⼀个 vptr 指针，⽽ vptr 是通过 this 指
针调⽤的，所以不能为 virtual；虚函数的调⽤关系，this->vptr->ctable->virtual function
```cpp

class A
{  
private:
    static int count ; // 类内声明
};

int A::count = 0 ; // 类外初始化，不必再加static关键字
---------------------------------------------------
class A
{  
private:
    static const int count = 0; // 静态常量成员可以在类内初始化
};

```

## const
* const 修饰基本类型数据类型：基本数据类型，修饰符 const 可以⽤在类型说明符前，也可以⽤在类型说明符后，其结果是⼀样的。
* const 修饰指针变量和引用变量，const 在\*左侧表示指针指向的值不能变， const在\*右侧表示指针指向的地址不能变
* const 在类中， const成员变量只能使用构造函数初始化列表的方式进行初始化。

# 5. C和C++区别
* c++新增关键字等：new delete auto explicit
* c++有函数重载的的概念（静态多态），c语言不能出现同名函数， c++有虚函数概念（动态多态），用来实现多态。
* c语言中strcut中不可以有成员函数，只能有成员变量， c++中都可以有，并且c++有class类这个概念，与strcut不同为struct默认pulic class默认private
* c语言没有模板函数概念，如果实现必须用到宏，c++有模板函数概念，提高了函数的复用
* c++提供stl标准库和容器

# 6. 说一下c++中怎么定义常量，常量存放在哪个区域
* 局部常量存在栈中
* 全局常量编译器不分配内存，放在符号表中提高访问速度
* 字面值常量存放在常量区


# 7. c++中重载和重写有什么区别
  
* 重载：overload，表示同一可访问区被声明的几个具有不同参数列表的同名函数，依赖于c++函数名字的修饰会将参数加在后面，可以是参数类型，个数，顺序的不同，根据参数列表决定调用哪个类型，C++中函数重载要求函数名相同但函数参数列表不同。重载不关心函数的返回类型。如果两个函数只有返回值不同，算是函数重定义，在同一个作用域内不能有两个具有相同名称和参数列表的函数

* 重写：override, 表示在派生类中重新定义父类除了函数体外完全相同的虚函数（virtual 函数），注意被重写的函数不能是static的，一定得是虚函数，并且函数名字，参数列表，返回值需要完全一样。子类和基类都共享一个静态函数和静态成员变量。

* 重定义：派生类中重新定义父类中相同名字的非虚函数，参数列表和返回类型都可以不同，即父类中除了定义成virtual且完全相同的同名函数才不会被派生类中的重名函数所隐藏（重定义）。一般应该避免这种，造成混淆和可阅读性下降。

# 8. c++所有的构造函数
1. 无参数构造函数 ( 默认构造函数 )：编译器会自动生成，如果不想使用编译器自动生成的，就需要自己显示的写一个
2. 一般构造函数：也称重载构造函数，一个类可以有多种重载构造函数，前提是参数的个数或类型不同
3. 拷贝构造函数：拷贝构造函数的函数参数为这个类另一个对象的常引用，用于根据一个已经存在的对象复制出一个新的该类的对象，将已经存在的对象的数据成员的值一一复制到新创建的对象中。当类中有指针成员函数时，必须自己定义拷贝构造函数，防止默认的复制构造函数是浅拷贝。
4. 移动构造函数：函数参数为这个类的另一个对象的右值引用，用于交换对象的所有权，常见于unique_ptr的实现 / 使用右值直接在类上构造。
5. 类型转换构造函数： 根据一个别的类型的对象创建一个本类型的对象，如果不想让编译器进行隐式转换的话，需要在构造函数前声明explicit
6. 赋值运算符的重载：一般来说参数推荐按值传递。注意，等号左右对象必须是已经存在的才走赋值运算符， 如果等号左边正在初始化，走拷贝构造函数。

# 9. c++ 4种强制转换

c++的四种强制转换包括：static_cast<T>(), dynamic_cast<T>(), const_cast<T>(), reinterpret_cast<T>()
* static_cast: 明确指出类型转换，没有动态类型检查，所以上行转换安全，（派生类转换为基类安全）， 下行转换不安全，（基类转换为派生类），主要用于执行非多态的转换操作。
* dynamic_cast: 专门用于派生类之间的转换，T 必须为类指针，类引用 或 void* ，对于下行转换是安全的，当类型不一致时，转换过来的的为空指针。如果时static_cast转换过来的错误意义的指针，可能造成非法访问。
* const_cast: 用于const属性的转换，比如给有const修饰的类型去除const 或 无const修饰的加上const
* reinterpret_cast: 一般不使用，高危操作，从底层对数据类型重新解释，可以将整形转换为指针，将指针转换为数组，将指针和引用互相转换。

# 10. 指针和引用的区别
* 区别1：指针是一个实体，引用只是一个原对象的别名
* 区别2：指针指向一块内存，指针的值就是指向内存的地址，编译时，将指针变量名和指针变量的地址添加到符号表中，指针的内容是可以改变的，有const和非const之分。引用只是一块内存的别名，编译时将引用变量名和引用对象的地址添加到符号表符号表一经完成不可修改，所以引用必须只能在定义是绑定到已经存在的一块内存上，后续就不可以再修改了，也没const和非const之分
* 区别3：sizeof 指针得到的是指针本身的大小 32位是4 字节， 64 位是8字节，sizeof引用得到的是原对象的大小。
* 区别4： 作为参数是，传入指针是传入原指针地址的拷贝，在函数内部修改指针指向不会造成原指针的变化，改变指针的值会变化；引用传入的是原对象的地址。

# 11. 野指针和悬空指针有什么区别？如何避免？

* 野指针：没有被初始化过的指针
* 悬空指针：一开始指向一块分配的内存，但后来被释放的指针。
* 无论野指针还是悬空指针都指向一块无效的内存空间，访问这个内存空间会导致未定义行为

# 12. 说一下const修饰的指针如何区分？

```
1. *号左边都代表修饰指针指向的对象，表示这个指针指向的值不可变 const int * val;
2. *号右边都代表修饰指针，表示这个指针的地址不可以被改变 int * const val;
3. 两边都有表示值不可变，地址也不可变。const int* const val;

```

# 13. 简单说一下函数指针

*  首先是定义：函数指针是指向函数的指针变量，函数指针首先自己是一个指针变量，该指针变量指向一个具体的函数。
*  编译时，每一个函数都有一个入口地址，该入口地址就是函数指针指向的地址，有了指向函数的指针变量后，可以用这个指针调用该函数。

```cpp
void func(char* p) {....}

void (*pf)(char* p){....}

pf = func;//函数指针pf指向函数func
pf(p);//通过函数指针pf调用函数func

```

# 14. 堆和栈的区别

1.  栈：
* 编译器自动分配，连续的内存空间， 大多数编译器，函数的参数都是从右向左入栈，这样方便可变参数模板那个特性，第一个函数数量的参数会被放在栈顶，方便解析。函数调用后，局部变量先出栈，然后是参数，最后是栈顶函数指针。

2. 堆
* 程序员自动分配，new malloc/ delete free分配 ，不释放会造成内存泄漏。不连续的内存空间，实际上内存中有一个空闲内存的链表，当有程序申请时，会遍历空闲链表找到第一个大于等于申请大小的内存空间，一般分配内存大小是，会将对象数量写入空间的头部， delete []时会先访问这块空间的头部，得到需要析构对象的数量，再依次执行析构函数。

# 15. 函数传递参数有几种方式

答：3种，按值传递，按指针传递， 按引用传递

* 按值传递，实际上是实参的拷贝，在函数内部对这个参数进行的操作不会影响到外部
* 按指针传递，也是按值传递的一种，只不过是原来值地址的拷贝，对这块地址进行操作时，会影响外部参数的值的变化，不过对于这个指针指向的操作不会影响外部实参
* 按引用传递，实际上就是把引用对象的地址放在函数的栈空间内，对函数内形参的任何操作都可以影响外部实参。