<!--
 * @Author: zzzzztw
 * @Date: 2023-06-07 19:51:26
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-06-09 23:18:43
 * @FilePath: /myLearning/项目总结/rpc.md
-->

# TinyRPC项目详解

## RPC框架解决什么问题

1. 相比http协议更加灵活，准确的说rpc不是一种协议，而是一种远程过程调用的方法，我们在此之上灵活使用我们自定义的协议格式，可以避免http比较冗长的报文，提高效率
2. 由于rpc更加灵活，所以更容易扩展和继承例如注册中心或负载均衡等功能
3. 相比于普通http的json，我们可以使用更高效的序列化协议，将文本转为2进制传输，获得更高性能。

## 写一个RPC框架需要考虑什么
1. 我们使用什么传输协议，用什么编码方式
2. 可用性问题：连接超时，或支持异步请求，负载均衡等。
3. 客户端并不关心服务端的地址和部署位置，只关心调用并得到结果，所以引出注册中心和负载均衡问题。

# 通信部分 

* 涉及codec.go gob.go client.go server.go

1. 客户端与服务端的通信需要协商一些内容，这里实现了 option + {header{server.method} | body} +  {header | body} ....的格式，首先使用json传递我们使用的密钥和解码方式，通过两次握手的形式，保证服务端处理完option后，客户端收到处理完成的消息后再发送header|body请求防止粘包，每进来一个新conn，就开一个协程去进行我们的处理逻辑。
2. 服务端处理后，使用读出的解码方式去对客户端发来的headr|body进行解析，通过解析请求头(按.来分割提供服务的对象和其具体调用的服务)
3. 解析完请求后，拿到服务对象和其具体调用的服务名。通过反射，拿到参数类型的返回值类型，然后通过报文拿到写入的参数（按顺序封装成结构体）通过.method.Func.Call()调用函数，得到返回值reply。

# 服务注册register

1. 维护了一个sync.map[服务名]服务实例， sync.map线程安全，使用空间换时间方法，底层由read和dirty两个哈希表来进行读写分离，提高效率，适用于读多写少场景。如果写多场景，会导致未命中次数miss字段数目增加，最终dirty map升级为read，这是on复杂度，效率会降低但仍是线程安全的。
2. 请求的消息会被分解为服务名，然后在这个哈希表中取到其实例。

# 超时处理

