<!--
 * @Author: zzzzztw
 * @Date: 2023-04-03 16:38:25
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-04-03 21:53:26
 * @FilePath: /cpptest/mysql45/06全局锁和表锁.md
-->
# 全局锁和表锁

* 根据锁的粒度大概分为：全局锁，表级锁，行级锁三类
  
## 全局锁：
1. 全局锁即给整个数据库加锁，mysql提供给全局加读锁的方法：```Flush tables with read lock (FTWRL)```,执行之后整个数据库只能处于只读的状态，数据的更新语句，数据的定义语句（包括建表，改表结构）和开启/提交事务类的操作都会被阻塞。
2. 使用典型场景为：全库的逻辑备份，把整库都select出来存成文本。
3. 全局锁解决的问题为保证视图的一致性（发起数据库备份时，不同表之间备份顺序会有先后时间差，这个时间差内对表的操作可能造成数据不一致）-------这个可以被innodb引擎的可重复读隔离代替，拿到一致性视图。但别的引擎如myisam不支持事务，所以还是需要全局锁（只读）
* 问题：
* 通过set global readonly=true的方式也能让全库只读，为什么不用?
* 答：1. 有些系统中，readonly的值会被用来判断是不是从库。2. 异常处理机制不安全，FTWRL发生异常会释放这个锁， readonly不会，会一直阻塞。

## 表级锁
* 表级锁分为两种：1. 表锁 2. 元数据锁
*  表锁：可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。
*  元数据锁：MDL，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候（比如增加一列，删减一列），加 MDL 写锁。
*  注意：开始一段事务之后对于表增删改查，加了MDL读锁，然后想改变表结构，会试图加MDL写锁，由于事务未提交会被阻塞，之后所有的对这个表的增删改查都要加MDL读锁，但前面有写锁，所以全部操作都会被阻塞，导致系统崩溃。正确的做法是先检查长事务，再在alter table中设定等待时间，超过等待时间直接结束，不阻塞后面的操作，最后再由工程师整体更改。