<!--
 * @Author: zzzzztw
 * @Date: 2023-05-08 19:12:06
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-05-09 19:03:06
 * @FilePath: /myLearning/mysql45/20-21加锁与幻读.md
-->
# 行锁/间隙锁+幻读

- 两阶段锁协议，一个select for update + 写锁， 没有索引的话会导致整张表被锁抓住，select时上锁，提交事务才释放锁。有索引的话是对应行加锁，如果是可重复读还还会加上全表的间隙锁。读锁也是一样，在事务释放才解锁。

1. 幻读值得是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行
2. 幻读发生在当前读，可重复读的select是快照读不会读到，不会读到当前的事务，幻读仅指新插入的行

### 幻读有什么问题

幻读会导致数据不一致的问题，即使把所有的记录都加上锁，由于插入的这个数据不存在，还是可以插入。

### 间隙锁解决幻读。间隙锁和插入冲突，和更新数值不冲突

- 间隙锁是在可重复读隔离条件下才会生效，读提交不会生效 

1. 数据有数据之间有间隙，例如插入了两个值0，5，那么0到5之间就是一段间隙，其次默认插入两个无穷大的值，会锁住小于最小和大于最大的间隙，一句话总结，所有间隙都被锁住。
2. 锁住之后就不允许向间隙中插入新的值了，间隙锁和读写锁不冲突，间隙锁之间也不冲突，之和向间隙中插入的操作冲突。

### 行锁 + 间隙锁统称为next-key lock，就是锁住这一行和它的左区间

1. 只有在可重复读隔离条件下才生效
2. 两个原则两个优化一个bug：
   - 原则1：加锁的基本单位是next-key lock， 前开后闭区间
   - 原则2：查找过程中访问到的对象才会加锁（查哪个索引或对象，对于哪个索引或对象加锁，更新其他索引还是可以的，总结一句话是锁住的一列不是一行），如果查询对象没有索引，那么全表扫描，全表加锁，直到commit释放
   - 优化1：索引上的等值查询，给唯一索引加锁时，next-keylock 退化为行锁
   - 优化2：索引上的等值查询，向右遍历时且最后一个不满足值条件的，next-keylock退化为间隙锁
   - bug：唯一索引上的范围查询会访问到第一个不满足条件的值位置，加一片next-key ，8.029版本以后修复了不用管

3. 加limit限定，可以减少锁的范围
4. 会导致死锁，注意，可能两个线程对某一个间隙同时加了间隙锁，导致死锁，next-key lock的逻辑是先加间隙锁，再加行锁