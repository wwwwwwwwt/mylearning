<!--
 * @Author: zzzzztw
 * @Date: 2023-03-29 14:48:18
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-04-02 17:46:32
 * @FilePath: /cpptest/mysql45/04 - 05索引.md
-->
# 1.索引
* 优点：提高查询效率，通过对索引排序降低成本
* 缺点：索引也要占空间名单insert，update，delete需要进行页分裂和页合并，效率降低。
## 常见的索引模型
1. 哈希表：以key-val存储，但大量数据容易出现哈希冲突，拉链法会退化成o(n),范围查询会全表扫描。
2. 有序数组:查询ologn复杂度，但插入记录就要挪动后面所有记录，成本很高，只适用于静态存储，如2020年的某个城市人口信息
3. 二叉查找树BST：解决排序问题，但无法保证平衡，可能退化成单链表
4. 二叉平衡树AVL：通过旋转解决了平衡问题，但旋转操作导致效率很低
5. 红黑树：引入红黑节点，解决了AVL旋转次数过多效率太低问题，但树高仍会过高，io次数太多
6. B树：通过将二叉树变为多路平衡查找树，解决树过高问题
7. B+树，在B树的基础上，将非叶节点改造为不存储数据的纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效。
   * B+树，采用n叉树，n取决于==== 页/（索引+指针）的大小，例如，一个页16k， 一个bigint索引8B，一个指针6B，n = 16*1024 / 8+6 约等于1170.
9. 问题：为什么innodb选择B+树而不选其他的
   * 答：
      * 数据一定时，其他树层级更高，效率慢。 
      * B+树非叶子节点不存放数据只存放key，一页中能存放更多的key，B树所有节点存放key-val，相同页大小，存放的指针更少，要保存更多的数据只能增加树的高度，导致性能降低
      * 哈希不支持范围查询。
## 索引分类
1. 主键索引：针对表中主键创建的索引，不创建的话默认会自动创建，只能存在一个，PRIMARY关键字指定
2. 唯一索引：避免同一个表中某列数据中的值重复，可以有多个，关键字UNIQUE
3. 常规索引：快速定位特定的数据，可以有多个
4. 全文索引：用于全文查找文本中的关键词，可以有多个 关键词FULLTEXT
5. 聚簇索引：将数据存储与索引放到了一块，索引结构的叶子节点保存对应的行数据， 必须有且只能有一个
6. 二级索引：索引的叶子节点关联的是对应的主键，可以存在多个
## 聚簇索引选取原则
1. 有主键选主键
2. 无主键选第一个UNIQUE键，唯一索引
3. 都没有，会自动生成一个rowid当隐藏的聚簇索引
## 二级索引回表查询流程
1. 现在二级索引中查到对应的主键，再拿着主键去聚簇索引中寻找对应的数据，如下图
<center>

![](img/04(1).jpg)

</center>

2. 思考题：  
   1. innodb主键索引的B+树有多高？
   * 答：
     * 首先先默认1170叉树， 一页16kb，一个指针6字节，一个bigint8字节 16 * 1024 /14约等于1170，说明一页能存1170个索引
     * 数据行：一页16k，假设一行数据1k，一页能存16行这个数据
     * 总共：高度为2，1170 * 16 约为 2w数据， 告诉为3 1170 * 1170 * 16 约为2000w条数据
# 2.innodb索引索引模型
1. 在innodb中，每一个索引都对应着一颗B+树。
2. 主键索引也叫聚簇索引，主键索引的叶子节点存储整行数据
3. 非主键索引也叫二级索引，叶子节点存储对应的主键的值
## 一个典型案例，要求建表语句里一定要有自增主键：NOT NULL PRIMARY KEY AUTO_INCREMENT。
1. 意思：插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。
2. 自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
3. 而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。
4. 除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。
* 例外：有些业务的场景需求是这样的：只有一个索引；该索引必须是唯一索引。你一定看出来了，这就是典型的 KV 场景。由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。

# 3.回表
1. 假设有一个二级索引的范围查询，那么需要进行几次树的搜索，回表几次?在二级索引树进行一次搜索，找到在叶子节点找到范围区间，每搜索到一条数据，就需要回表查询一次，所以需要在主键索引的B+树上搜索范围内数据的个数次。
2. 在二级索引的B+树上每查一条数据就回表一次。
## 索引优化避免回表过程

