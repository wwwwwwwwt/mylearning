<!--
 * @Author: zzzzztw
 * @Date: 2023-04-19 20:53:16
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-04-19 21:37:32
 * @FilePath: /myLearning/mysql45/14count（*）.md
-->
# count(*)这么慢该怎么办

1. count(*)的实现方式：
   * myisam中记录了一个总行数，count(*)直接返回这个数
   * innodb中需要一行一行读出行数并累计计数
    * 注意：这里提到的是没有where过滤条件的，有的话myisam也没这么快

2. 为什么innodb不想myisam一样把总行数记录下来
   * 因为mvcc多版本并发控制，实际返回多少行，也是不确定的可能会变。

3. show table status中的 rows这个是个估计值，可能误差能达到50%

4. 总结：  
   1. MyISAM 表虽然 count(*) 很快，但是不支持事务；
   2. show table status 命令虽然返回很快，但是不准确；
   3. InnoDB 表直接 count(*) 会遍历全表，虽然结果准确，但会导致性能问题。

5. 如果我们经常需要显示行数，应该怎么做？
   1. 用缓存系统保存计数，起一个redis，先count（*）一次，每插入一行，行数+1.但由于插入和加一有时间差，所以这个数也不太准。
   2. 用一个新表存行数，并开启事务

## 不同的count（）的用法

1. count(*)、count(主键 id)、count(字段) 和 count(1)
2. count（）的含义：聚合函数，对于返回的结果，一行行判断如果不是null就+1，是null就不加，最后返回累计值。
3. 分析性能差异：
   1. 对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。（需要去那个行看看是不是被删了之类的）
   2. 对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。（无需任何判断，就数1个数）
   3. 对于 count(字段) 来说：如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。（需要去这个字段看看，是否允许null，在判断是不是被删了要不要+1）
   4. 但是 count(\*) 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(\*) 肯定不是 null，按行累加。
4. 总结：速度 count(字段) < count(主键 id) < count(1) ≈ count(\*)，所以尽量使用 count(\*)。