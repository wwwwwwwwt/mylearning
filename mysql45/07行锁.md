<!--
 * @Author: zzzzztw
 * @Date: 2023-04-06 14:49:41
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-04-06 16:27:02
 * @FilePath: /cpptest/mysql45/07行锁.md
-->
# 行锁

1. innodb引擎支持行锁， 但Mylsam不支持行锁。
2. 顾名思义行锁就是针对数据表中行数据记录的锁，比如事务A更新了一行，而这时候事务B也要更新同一行，那么事务B需要等带A事务更新完成后才能进行更新。

## 两阶段锁
1. innodb中，行锁是数据需要的时候才加上的，但并不是不需要了就立刻释放，而是等待当前事务结束后才释放。这就是两阶段锁协议。
2. 由于两阶段锁的存在，所以在一个事务中，我们要尽量将热点数据行/ 最有可能造成锁冲突/ 并发度最高的锁尽量往后放，放在最靠近commit的地方。


## 死锁和死锁检测

<center>

![](img/07(1).png)

</center>

1. 如上图所示，事务A等待着事务B释放id = 2的行锁， 事务B等待着事务A释放id = 1的行锁，事务A与事务B都在互相等待对方释放资源，这就是死锁状态。
2. 当出现了死锁情况，有以下两种策略
   * 第一个被锁住的线程超时退出，这是第二个线程就会接触死锁进行下去，但默认值50s，一般不使用，手动设置值太小又有可能是正常锁等待，出现误伤。
   * 死锁检测，发现死锁后主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。
3. 一般使用死锁检测来解决，但它的消耗很大，检测代价o(n^2)，解决方法是想办法减少同时对同一行更新的并发度，降低N值。
   * 一种思路：确保这个业务不发生死锁，直接关掉死锁检测，但风险很大。
   * 控制并发度：（不能在客户端做并发控制，最后汇总到数据库服务端仍是一个很大的数字）
   * 1. 做一个中间件，如proxy对同一行数据修改的请求排队的功能。
   * 2. 修改mysql源码，基本思路就是，对于相同行的更新，在进入引擎前进行排队，降低并发的N
   * 3. 将一行的数据改成多行来降低所冲突，比如一个数据，分成十个小数据记录的总和，这样每次对这个数据操作就随机找一个记录来相加，冲突概率就变成原来的十分之一，但可能要对逻辑进行特殊处理，如一个数据为0了，要从其他9行数据不为0的数据行尝试减少。
  