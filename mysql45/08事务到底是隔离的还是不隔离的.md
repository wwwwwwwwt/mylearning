<!--
 * @Author: zzzzztw
 * @Date: 2023-04-06 16:27:33
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-04-06 21:26:46
 * @FilePath: /cpptest/mysql45/08事务到底是隔离的还是不隔离的.md
-->
# 快照读和当前读

1. 有关MVCC版本控制链请见 03.事务隔离这篇文章中解释， 这里只截取一部分

### readview视图机制
1. 重要属性：
*  creator_trx_id：当前事务id号
*  m_id：类似一个数组当前事务开启时其他活跃的事务id号（未提交的事务）
*  min_trx_id：当前系统活跃的最小事务号id
*  max_trx_id：当前系统活跃的最大事务号id
2. 具体原理：可以类比于一条坐标轴，被min_trx_id与max_trx_id分为了三段。举例子，我们默认在默认隔离条件可重复读repeatable read条件下。

<center>

![](img/03(3).png)

</center>

* 如果一个事务想要获取某个数据时，如果当前数据的row_trx_id小于当前活跃最小事务id（min_trx_id），就表示这条数据是在当前事务开启之前，其他事务就对他进行了修改并提交，所以当前事务可以读取到 
* 如果一个事务想要获取某个数据时，如果当前数据的row_trx_id大于当前活跃最大事务id（max_trx_id），就表示这条数据是在当前事务开启之后产生的数据，其他事务并对他进行了修改（undo log记录的是修改数据，就算不提交依旧还会生成undo log，所以尽量不要使用长事务，以免生成很大的undo log删不了），所以当前事务不可以读取到这条数据，需要按照undo log版本链回滚。 
* 如果想读的这个数据版本id处于min_trx_id 和 max_trx_id 之间 分为两种情况：
  * 这个数据版本版本id在m_ids中，表示是和当前事务期间一起开启的事务，并对这条数据的修改，在可重复读隔离下不能被当前事务看到，所以不能读到这条数据，需要按照undo log版本链向上寻找
  * 如果这个数据版本不在m_ids中，那么可以读到这个版本的数据（只发生在读提交隔离条件下（每次sql语句都生成视图），可重复读只在创建事务时创建一个视图，所以不会出现这种情况,只要创建时在m_ids时，本事务期间就一直会在）
1. 总结
* 版本未提交，不可见
* 版本已提交，并且在视图创建前提交的，可见
* 版本已提交，并且在视图创建后提交的，不可见  
* 注意：在可重复读隔离级别下，更新操作都是都是当前读（加共享锁/读锁，share mode），先读取数据的最新版本，在进行更新操作，并且会加写锁
## 注意：但此时其他活跃中的事务也尝试对这条数据进行了修改

  *  第一个事务读取数据并进行修改，但是在提交修改之前，(第二个事务也读取了该数据并进行了修改，并先于第一个事务提交了修改) 这句话是错的，第一个数据读取数据并更改，第二个事务尝试去修改，会被阻塞，直到事务A commit提交后，释放写锁，第二个事务才能执行。
  *  当第二个事务读取事务并进行修改并进行提交，第一个事务再进行update操作，首先会进行当前读操作，把当前最新的数据读入，在最新的数据基础上进行更新。注意，这个操作是当前读，之前的都是按照一致性读，所以结论为，当更新操作update时是当前读 （select语句加锁也是当前，select * from A where id = 1 lock in share mode / for update ) 都能读取到最新数据 ，然后自己在查询事务时，发现是自己更新的，自己能看到，相当于自己的版本被刷新了。
  *  如果版本A更新完这条语句，版本B再更新，可重复读版本下，版本A查询到的还是版本A所提交的。

##  思考题，也是对上段第一句话的补充
* 这样乐观锁的情况下，第二个事务提前修改并提交，第一个事务再提交会报错返回。解决方案，每次更新不管成功失败，直接结束当前事务，另起一个新事务。
思考题，RR下，用另外一个事物在update执行之前，先把所有c值修改，应该就可以。比如update t set c = id + 1。
这个实际场景还挺常见——所谓的“乐观锁”。时常我们会基于version字段对row进行cas式的更新，类似update ...set ... where id = xxx and version = xxx。如果version被其他事务抢先更新，则在自己事务中更新失败，trx_id没有变成自身事务的id，同一个事务中再次select还是旧值，就会出现“明明值没变可就是更新不了”的“异象”（anomaly）。解决方案就是每次cas更新不管成功失败，结束当前事务。如果失败则重新起一个事务进行查询更新。