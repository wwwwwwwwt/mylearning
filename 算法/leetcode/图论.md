<!--
 * @Author: zzzzztw
 * @Date: 2023-04-06 09:07:07
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-06-24 18:11:40
 * @FilePath: /myLearning/算法/leetcode/图论.md
-->
# floyed 算法

1. lc 399除法求值
* 思路： unordered_map<string, unordered_map<string,int>>dis 存放点与点之间的距离， unordered_set<string>存点
* 先建立点之间的关系，类似邻接表
* 再跑一边floyed更新点之间的距离，题目说不存在矛盾，所以floyed求出的最短路就是唯一路
* 不存在的就是-1

```cpp
    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        unordered_map<string, unordered_map<string, double>>dis;
        unordered_set<string>g;
        for(int i = 0;i<equations.size();i++){
            string a = equations[i][0], b = equations[i][1];
            double c = values[i];
            dis[a][b] = c, dis[b][a] = 1/c;
            g.insert(a), g.insert(b);
        }

        for(auto k : g){ //枚举中转跳点
            for(auto i : g){
                for(auto j : g){
                    if(dis[i][k] && dis[k][j]){
                        dis[i][j] = dis[i][k] * dis[k][j];
                    }
                }
            }
        }

        vector<double>res;
        for(int i = 0;i<queries.size();i++){
            string a = queries[i][0], b = queries[i][1];
            if(dis[a][b])res.push_back(dis[a][b]);
            else res.push_back(-1);
        }
        return res;
    }



```

# dijkstra

1. 1631 最小体力消耗路径

```cpp
class Solution {
public:
    static const int N = 110;
    using piii = pair<int, pair<int, int>>;
    int dis[N][N];
    bool st[N][N];
    int dx[4] = {-1,0,1,0}, dy[4] = {0,1,0,-1};
    int dijkstra(vector<vector<int>>& heights){
        memset(dis, 0x3f, sizeof dis);
        dis[0][0] = 0;
        priority_queue<piii, vector<piii>, greater<piii>>q;
        q.push({dis[0][0], {0,0}});
        while(q.size()){
            auto t = q.top();
            q.pop();
            int a = t.second.first, b = t.second.second;
            if(st[a][b])continue;
            st[a][b] = true;
            for(int i = 0; i < 4; i ++){
                int x = a + dx[i], y = dy[i] + b;
                if(x >= 0 && x < heights.size() && y >= 0 && y < heights[0].size()){
                    if(dis[x][y] > max(dis[a][b], abs(heights[x][y] - heights[a][b]))){
                        dis[x][y] = max(dis[a][b], abs(heights[x][y] - heights[a][b]));
                        q.push({dis[x][y], {x,y}});
                    }
                }
            }
        }
        return dis[heights.size() - 1][heights[0].size() - 1];
    }
    int minimumEffortPath(vector<vector<int>>& heights) {
        return dijkstra(heights);
    }
};
```


2. 778 上升泳池中游泳

```cpp
class Solution {
public:
    using pii = pair<int, pair<int, int>>;
    int res;
    static const int N = 55;
    bool st[N][N];
    int dis[N][N];
    int dx[4] = {-1,0,1,0}, dy[4] = {0,1,0,-1};
    int dij(vector<vector<int>>& grid){
        memset(dis, 0x3f, sizeof dis);
        dis[0][0] = 0;
        priority_queue<pii, vector<pii>, greater<pii>>q;
        q.push({0,{0,0}});
        dis[0][0] = grid[0][0];
        res = max(res, dis[0][0]);
        while(q.size()){
            auto t = q.top();
            q.pop();
            auto ver = t.second;
            
            if(st[ver.first][ver.second])continue;
            st[ver.first][ver.second] = true;
            for(int i = 0; i < 4;i ++){
                int x = ver.first + dx[i], y = ver.second + dy[i];
                if(x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size())continue;
                if(dis[x][y] >  max( dis[ver.first][ver.second], grid[x][y])){
                    dis[x][y] =  max( dis[ver.first][ver.second], grid[x][y]);
                    q.push({dis[x][y], {x, y}});
                }
            }
        }
        return dis[grid.size() - 1][grid[0].size() - 1];
    }
    int swimInWater(vector<vector<int>>& grid) {
        return dij(grid);
    }
};
```

3. 1102 得分最高的路径

* 思路：大根堆每次用最大值来更新，更新条件为min

```cpp
class Solution {
public:
    using pii = pair<int, pair<int, int>>;
    int res;
    static const int N = 55;
    bool st[N][N];
    int dis[N][N];
    int dx[4] = {-1,0,1,0}, dy[4] = {0,1,0,-1};
    int dij(vector<vector<int>>& grid){
        memset(dis, 0x3f, sizeof dis);
        dis[0][0] = 0;
        priority_queue<pii, vector<pii>, greater<pii>>q;
        q.push({0,{0,0}});
        dis[0][0] = grid[0][0];
        res = max(res, dis[0][0]);
        while(q.size()){
            auto t = q.top();
            q.pop();
            auto ver = t.second;
            
            if(st[ver.first][ver.second])continue;
            st[ver.first][ver.second] = true;
            for(int i = 0; i < 4;i ++){
                int x = ver.first + dx[i], y = ver.second + dy[i];
                if(x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size())continue;
                if(dis[x][y] >  max( dis[ver.first][ver.second], grid[x][y])){
                    dis[x][y] =  max( dis[ver.first][ver.second], grid[x][y]);
                    q.push({dis[x][y], {x, y}});
                }
            }
        }
        return dis[grid.size() - 1][grid[0].size() - 1];
    }
    int swimInWater(vector<vector<int>>& grid) {
        return dij(grid);
    }
};
```


# bellman_ford算法

* 787  K 站中转内最便宜的航班

```cpp
class Solution {
public:
    struct edge{
        int a;
        int b;
        int w;
        edge(int a,int b, int w ):a(a), b(b), w(w){};
    };
    static const int N = 110;
    int dis[N], backup[N];
    vector<edge>g;
    int bellman_ford(vector<vector<int>>& flights, int k, int src, int dst, int n){
        memset(dis, 0x3f, sizeof dis);
        dis[src] = 0;
        for(int i = 0; i <= k; i++){ //k次要加一， 因为第一次需要把自己dis更新了，之后再k次
            memcpy(backup, dis, sizeof dis);
            for(int j = 0; j < g.size(); j++){
                int a = g[j].a, b = g[j].b, w = g[j].w;
                dis[b] = min(dis[b], backup[a] + w);
            }
        }
        if(dis[dst] >= 0x3f3f3f3f)return -1;
        return dis[dst];
    }
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        for(int i = 0; i < flights.size(); i++){
            auto a = flights[i][0], b = flights[i][1], w = flights[i][2];
            g.push_back({a, b, w});
        }
        return bellman_ford(flights, k, src, dst, n);
    }
};


```


# spfa算法
* 解决负权边问题
* 核心思想：把如果更新的点不在队列里就放进队列里，在的话就不放进去了。st[i]记录i在不在队列中，dis更新距离
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 100010;
int dis[N];
bool st[N];
int n, m;
struct node{
    int b, w;
    node(int b, int w):b(b), w(w){};
};
vector<node>g[N];
int spfa(){
    memset(dis, 0x3f, sizeof dis);
    dis[1] = 0;
    queue<int>q;
    q.push(1);
    st[1] = true;
    while(q.size()){
        auto t = q.front();
        q.pop();
        st[t] = false;
        for(auto c: g[t]){
            auto j = c.b;
            if(dis[j] > dis[t] + c.w){
                dis[j] = dis[t] + c.w;
                if(st[j] == false){
                    st[j] = true;
                    q.push(j);
                }
            }
        }
    }
    if(dis[n] > 0x3f3f3f3f/ 2)return -2;
    return dis[n];
}
int main(){
    cin>>n>>m;
    int a, b, w;
    for(int i = 0; i < m; i++){
        cin>>a>>b>>w;
        g[a].emplace_back(b, w);
    }
    int t = spfa();
    if(t == -2)cout<<"impossible"<<endl;
    else cout<<t<<endl;
    return 0;
}

```