<!--
 * @Author: zzzzztw
 * @Date: 2023-04-06 09:07:07
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-06-17 08:51:26
 * @FilePath: /myLearning/算法/leetcode/图论.md
-->
# floyed 算法

1. lc 399除法求值
* 思路： unordered_map<string, unordered_map<string,int>>dis 存放点与点之间的距离， unordered_set<string>存点
* 先建立点之间的关系，类似邻接表
* 再跑一边floyed更新点之间的距离，题目说不存在矛盾，所以floyed求出的最短路就是唯一路
* 不存在的就是-1

```cpp
    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        unordered_map<string, unordered_map<string, double>>dis;
        unordered_set<string>g;
        for(int i = 0;i<equations.size();i++){
            string a = equations[i][0], b = equations[i][1];
            double c = values[i];
            dis[a][b] = c, dis[b][a] = 1/c;
            g.insert(a), g.insert(b);
        }

        for(auto k : g){
            for(auto i : g){
                for(auto j : g){
                    if(dis[i][k] && dis[k][j]){
                        dis[i][j] = dis[i][k] * dis[k][j];
                    }
                }
            }
        }

        vector<double>res;
        for(int i = 0;i<queries.size();i++){
            string a = queries[i][0], b = queries[i][1];
            if(dis[a][b])res.push_back(dis[a][b]);
            else res.push_back(-1);
        }
        return res;
    }



```

# dijkstra

1. 1631 最小体力消耗路径

```cpp
class Solution {
public:
    static const int N = 110;
    using piii = pair<int, pair<int, int>>;
    int dis[N][N];
    bool st[N][N];
    int dx[4] = {-1,0,1,0}, dy[4] = {0,1,0,-1};
    int dijkstra(vector<vector<int>>& heights){
        memset(dis, 0x3f, sizeof dis);
        dis[0][0] = 0;
        priority_queue<piii, vector<piii>, greater<piii>>q;
        q.push({dis[0][0], {0,0}});
        while(q.size()){
            auto t = q.top();
            q.pop();
            int a = t.second.first, b = t.second.second;
            if(st[a][b])continue;
            st[a][b] = true;
            for(int i = 0; i < 4; i ++){
                int x = a + dx[i], y = dy[i] + b;
                if(x >= 0 && x < heights.size() && y >= 0 && y < heights[0].size()){
                    if(dis[x][y] > max(dis[a][b], abs(heights[x][y] - heights[a][b]))){
                        dis[x][y] = max(dis[a][b], abs(heights[x][y] - heights[a][b]));
                        q.push({dis[x][y], {x,y}});
                    }
                }
            }
        }
        return dis[heights.size() - 1][heights[0].size() - 1];
    }
    int minimumEffortPath(vector<vector<int>>& heights) {
        return dijkstra(heights);
    }
};
```


2. 778 上升泳池中游泳

```cpp
class Solution {
public:
    using pii = pair<int, pair<int, int>>;
    int res;
    static const int N = 55;
    bool st[N][N];
    int dis[N][N];
    int dx[4] = {-1,0,1,0}, dy[4] = {0,1,0,-1};
    int dij(vector<vector<int>>& grid){
        memset(dis, 0x3f, sizeof dis);
        dis[0][0] = 0;
        priority_queue<pii, vector<pii>, greater<pii>>q;
        q.push({0,{0,0}});
        dis[0][0] = grid[0][0];
        res = max(res, dis[0][0]);
        while(q.size()){
            auto t = q.top();
            q.pop();
            auto ver = t.second;
            
            if(st[ver.first][ver.second])continue;
            st[ver.first][ver.second] = true;
            for(int i = 0; i < 4;i ++){
                int x = ver.first + dx[i], y = ver.second + dy[i];
                if(x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size())continue;
                if(dis[x][y] >  max( dis[ver.first][ver.second], grid[x][y])){
                    dis[x][y] =  max( dis[ver.first][ver.second], grid[x][y]);
                    q.push({dis[x][y], {x, y}});
                }
            }
        }
        return dis[grid.size() - 1][grid[0].size() - 1];
    }
    int swimInWater(vector<vector<int>>& grid) {
        return dij(grid);
    }
};
```

3. 1102 得分最高的路径

* 思路：大根堆每次用最大值来更新，更新条件为min

```cpp
class Solution {
public:
    using pii = pair<int, pair<int, int>>;
    int res;
    static const int N = 55;
    bool st[N][N];
    int dis[N][N];
    int dx[4] = {-1,0,1,0}, dy[4] = {0,1,0,-1};
    int dij(vector<vector<int>>& grid){
        memset(dis, 0x3f, sizeof dis);
        dis[0][0] = 0;
        priority_queue<pii, vector<pii>, greater<pii>>q;
        q.push({0,{0,0}});
        dis[0][0] = grid[0][0];
        res = max(res, dis[0][0]);
        while(q.size()){
            auto t = q.top();
            q.pop();
            auto ver = t.second;
            
            if(st[ver.first][ver.second])continue;
            st[ver.first][ver.second] = true;
            for(int i = 0; i < 4;i ++){
                int x = ver.first + dx[i], y = ver.second + dy[i];
                if(x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size())continue;
                if(dis[x][y] >  max( dis[ver.first][ver.second], grid[x][y])){
                    dis[x][y] =  max( dis[ver.first][ver.second], grid[x][y]);
                    q.push({dis[x][y], {x, y}});
                }
            }
        }
        return dis[grid.size() - 1][grid[0].size() - 1];
    }
    int swimInWater(vector<vector<int>>& grid) {
        return dij(grid);
    }
};
```

