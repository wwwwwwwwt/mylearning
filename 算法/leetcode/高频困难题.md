<!--
 * @Author: zzzzztw
 * @Date: 2023-04-01 09:55:33
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-04-03 13:45:28
 * @FilePath: /cpptest/算法/leetcode/高频困难题.md
-->
4. 寻找两个正序数组的中位数
* 思路，由于两个数组全是排序的，所以可以在每个数组中，先选取第k/2个数字进行比大小，小的数组的前k/2个数字就可以删去，下次从下一个数字开始遍历
* 注意边界，全部假设为nums1目前‘剩余’数字小于nums2中目前剩余数字的个数， 否则需要交换nums的位置
* 如果nums1数组元素没了 nums1.size() == i 那么答案就是nums2[j + k - 1]具体带进去算一下，nums1.size()等于0时，nums2.size()等于3，中位数是3/2+1第二个，是nums2数组中的下标1， j+k-1 = 0 + 2 - 1
* 如果k = 1了（这种情况只会出现在两个数组元素个数和为偶数，且寻找右边界时出现，我们需要找一个最小的右边界），所以min(nums1[i], nums2[j]);
* 计算下一轮起始点：si， sj 由于i可能越界所以si需要特判si = min(nums1.size(), i + k/2), sj = j + k/2
* 判断这一轮终点nums1[si - 1], nums2[sj - 1]谁大。
* 更新k，例如删去nums1前面的就k - (si - i)
```cpp

class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int sum = nums1.size() + nums2.size();
        if(sum % 2 == 0){
            int left = find(nums1, 0, nums2, 0, sum / 2);
            int right = find(nums1, 0, nums2, 0, sum /2 + 1);
            return (left + right) / 2.0;
        }
        else return find(nums1,0,nums2,0,sum / 2+1);
    }

    int find(vector<int>& nums1, int i ,vector<int>& nums2, int j, int k){
        if(nums1.size() - i > nums2.size() - j)return find(nums2, j ,nums1, i, k);
        if(i == nums1.size())return nums2[j + k - 1];
        if(k == 1)return min(nums1[i], nums2[j]);

        int si = min((int)nums1.size(), i + k/2);
        int sj = j + k/2;
        if(nums1[si - 1] < nums2[sj - 1]){
            return find(nums1, si , nums2, j, k - (si - i));
        }
        else return find(nums1, i, nums2, sj , k - (sj - j));
    }
};

```

10. 正则表达式匹配
* 思路：原串为空是一种可能的匹配情况，需要考虑进去，而匹配串为空不可能匹配任何原串，所以下标j从1开始
* 当匹配串下一个为\*时，就continue，因为下一个\*决定当前字符用几次，可以为0，也可以多次
* 当前字符不为*，只能老实匹配，s[i] == p[j]或者p[j] == '.'匹配任意字符
* 当前字符为*，两种情况，*匹配0个，就是f[i][j-2]（去除\*和之前那个字符，表示不用这个）或者匹配多个f[i-1][j]&& (s[i] == p[j-1] || p[j-1] == '.')表示去掉这个字符以后能不能匹配，然后当前s[i]和\*之前那个字符匹配
```cpp
class Solution {
public:
    static const int N = 25;
    bool f[N][N];
    bool isMatch(string s, string p) {

        s = " " + s;
        p = " " + p;
        f[0][0] = true;
        for(int i = 0;i<s.size();i++){
            for(int j = 1;j<p.size();j++){
                if(j + 1 < p.size() && p[j+1] == '*')continue;
                if(i && p[j] != '*'){
                    f[i][j] = f[i-1][j-1] &&(s[i]  == p[j] || p[j] == '.');
                }
                else if(p[j] == '*'){
                    f[i][j] = f[i][j-2] || i && f[i-1][j] && (s[i] == p[j-1] || p[j-1] == '.');
                }
            }
        }
        return f[s.size() - 1][p.size() - 1];
    }
};
```

301. 删除无效括号

