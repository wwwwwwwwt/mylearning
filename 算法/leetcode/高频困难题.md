<!--
 * @Author: zzzzztw
 * @Date: 2023-04-01 09:55:33
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-04-01 17:04:38
 * @FilePath: /cpptest/算法/leetcode/高频困难题.md
-->
4. 寻找两个正序数组的中位数
* 思路，由于两个数组全是排序的，所以可以在每个数组中，先选取第k/2个数字进行比大小，小的数组的前k/2个数字就可以删去，下次从下一个数字开始遍历
* 注意边界，全部假设为nums1目前‘剩余’数字小于nums2中目前剩余数字的个数， 否则需要交换nums的位置
* 如果nums1数组元素没了 nums1.size() == i 那么答案就是nums2[j + k - 1]具体带进去算一下，nums1.size()等于0时，nums2.size()等于3，中位数是3/2+1第二个，是nums2数组中的下标1， j+k-1 = 0 + 2 - 1
* 如果k = 1了（这种情况只会出现在两个数组元素个数和为偶数，且寻找右边界时出现，我们需要找一个最小的右边界），所以min(nums1[i], nums2[j]);
* 计算下一轮起始点：si， sj 由于i可能越界所以si需要特判si = min(nums1.size(), i + k/2), sj = j + k/2
* 判断这一轮终点nums1[si - 1], nums2[sj - 1]谁大。
* 更新k，例如删去nums1前面的就k - (si - i)
```cpp

class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int sum = nums1.size() + nums2.size();
        if(sum % 2 == 0){
            int left = find(nums1, 0, nums2, 0, sum / 2);
            int right = find(nums1, 0, nums2, 0, sum /2 + 1);
            return (left + right) / 2.0;
        }
        else return find(nums1,0,nums2,0,sum / 2+1);
    }

    int find(vector<int>& nums1, int i ,vector<int>& nums2, int j, int k){
        if(nums1.size() - i > nums2.size() - j)return find(nums2, j ,nums1, i, k);
        if(i == nums1.size())return nums2[j + k - 1];
        if(k == 1)return min(nums1[i], nums2[j]);

        int si = min((int)nums1.size(), i + k/2);
        int sj = j + k/2;
        if(nums1[si - 1] < nums2[sj - 1]){
            return find(nums1, si , nums2, j, k - (si - i));
        }
        else return find(nums1, i, nums2, sj , k - (sj - j));
    }
};

```

10. 正则表达式匹配


