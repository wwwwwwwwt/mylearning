# 高频二叉树

1. lc114 二叉树展开为链表

* 思路：查看当前节点的左节点，拿到左节点，寻找这个节点的最右边节点，使这个节点的右节点等于当前节点的右节点，当前节点的右节点等于当前节点的左节点，当前节点的左节点为nullptr。向右节点递归。

```cpp

class Solution {
public:
    void flatten(TreeNode* root) {
        while(root){
            auto p  = root->left;
            if(p){
                while(p->right){
                    p = p->right;
                }
                p->right = root->right;
                root->right = root->left;
                root->left = nullptr;
            }
            root = root->right;
        }
    }
};

```

2. 剑指offer36，二叉搜索树展变为双向链表

* 递归，建立头节点l和当前节点r

```cpp
class Solution {
public:
    Node* l, *r;
    void dfs(Node* root){
        if(root == nullptr)return;
        dfs(root->left);
        if(l == nullptr)l = r = root;
        else{
            r->right = root;
            root->left = r;
            r = root;
        }
        dfs(root->right);
    }
    Node* treeToDoublyList(Node* root) {
        if(root == nullptr)return nullptr;
        dfs(root);
        r->right = l;
        l->left = r;
        return l;
    }
};

```

3. 剑指offer2 展平二叉搜索树为单链表

* 递归重建一棵树，建立一个头节点l和一个cur 当头节点l为空时，说明递归到了头，建立一个新节点为root->val，l = cur = root->val, 否则就是添加节点的操作，cur->right = node, cur->left= null. cur = node

```cpp

class Solution {
public:
    TreeNode* l, *cur;
    void dfs(TreeNode* root){
        if(root == nullptr)return;
        if(root->left)dfs(root->left);
        if(l == nullptr){
            TreeNode* node = new TreeNode(root->val);
            l = cur = node;
        }
        else{
            TreeNode* node = new TreeNode(root->val);
            cur->right = node;
            cur->left = nullptr;
            cur = node;
        }
        if(root->right)dfs(root->right);
    }
    TreeNode* increasingBST(TreeNode* root) {
        if(root == nullptr)return nullptr;
        dfs(root);
        return l;
    }
};

```

4. 二叉搜索树的第k大节点
   
* 思路：右-中-左顺序递归，全局++count记录当前是几个节点，++count == k时，记录res记录当前节点值/

```cpp
class Solution {
public:
    int res ,count;
    void dfs(TreeNode* root, int k){
        
        if(count < k &&root->right)dfs(root->right, k);
        if(++count == k){
            res = root->val;
            return;
        }
        if(count < k && root->left)dfs(root->left, k);
    }
    int kthLargest(TreeNode* root, int k) {
        count = 0;
        res = 0;
        dfs(root, k);
        return res;
    }
};

```

5. 剑指offer26. 树的子结构
   
* 思路：如果子树Bnull了，那么就返回true。如果A为null了，B还没null说明不是子结构，返回false。如果当前A值和B值相同，那么就递归return dfs（A->left,B->left） && dfs(A->right, B->right);
* 主函数中 return dfs（A,B)|| dfs(A->left, B) || dfs(A->right,B);

```cpp

class Solution {
public:
    bool dfs(TreeNode* A, TreeNode* B){
        if(B ==NULL)return true;
        if(A == NULL && B!= NULL)return false;
        if(A -> val == B->val){
            return dfs(A->left, B->left) && dfs(A->right, B->right);
        }
        return false;
    }
    bool isSubStructure(TreeNode* A, TreeNode* B) {

        if(A == NULL||B == NULL)return false;

        return  dfs(A,B) || isSubStructure(A->left, B)|| isSubStructure(A->right, B);
    }
};


```


6. 剑指offer27. 二叉树镜像

* 思路：遍历一遍，然后交换左右子节点

```cpp
class Solution {
public:
    void dfs(TreeNode* root){
        if(root == NULL)return;
        dfs(root->left);
        dfs(root->right);
        swap(root->left, root->right);
    }
    TreeNode* mirrorTree(TreeNode* root) {
        if(root == NULL)return NULL;
        dfs(root);
        return root;
    }
};

```

7. 剑指offer28. 对称二叉树

* 如果左右子树都空了，那么返回true；其中有一个空了另一个没空就返回false。如果左节点和右节点值相同了，就递归左子树的左，右子树的右和左子树的右，右子树的左，return l&&r

```cpp
class Solution {
public:
    bool dfs(TreeNode* left, TreeNode* right){
        if(left == NULL && right == NULL)return true;
        else if(left != NULL && right == NULL)return false;
        else if(left == NULL && right != NULL)return false;
        else if(left->val == right->val){
            bool l = dfs(left->left, right->right);
            bool r = dfs(left->right, right->left);
            return l && r;
        }

        return false;
    }
    bool isSymmetric(TreeNode* root) {
        if(root == NULL)return true;
        return dfs(root->left, root->right);
    }
};

```